class A {
  // ...
  getB() {
    return new B();
  }
}

class B {
  // ...
  getC() {
    return new C();
  }
}

class C {
  // ...
  doSomething() {
    // Логика
  }
}

// Использование транзитивного обращения
const a = new A();
a.getB().getC().doSomething();


//Что было плохо и почему?
// Класс А сильно зависит от В, а В от С
// это снижает гибкость и усложняет тестирование,
// тк для одного объекта потребуются все зависимые объекты


// Что стало лучше и почему?
// не нужно создавать экземпляры класса самостоятельно, более короткий вызов
// еще можно рассмотреть добавление абстрактного класса и наследоваться от него

// class A {
//   // ...
//   doSomething() {
//     const b = this.getB();
//     const c = b.getC();
//     c.doSomething();
//   }
//
//   getB() {
//     return new B();
//   }
// }
//
// class B {
//   // ...
//   getC() {
//     return new C();
//   }
// }
//
// class C {
//   // ...
//   doSomething() {
//     // Логика
//   }
// }
//
// // Использование
// const a = new A();
// a.doSomething();